---
layout: post
title:  "데이터 중심 애플리케이션 설계 02장"
date:   2022-03-03
comments: true
project: true
excerpt: "데이터 중심 애플리케이션 설계 02장"
categories: book
---

## 데이터 모델과 질의 언어

데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 지대한 영항을 미친다.

각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 표현하는 방법이다. => 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다.

데이터 모델은 그 위에서 소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.

이번 장에서는 다음과 같ㅊ은 데이터 모델을 살펴본다

- 관계형 모델(relational model)과 문서 모델(document model)
- 그래프 기반 데이터 모델(graph-based data model)

## 관계형 모델과 문서 모델

데이터는 relation(SQL에서는 table)으로 구성되고 각 관계는 순서없는 tuple(SQL에서는 row)모음이다.

관계형 데이터베이스는 초기에 비즈니스 데이터 처리로 사용이 되었으나 본래 영역을 넘어 다양한 서비스에도 사용된다.

### NoSQL의 탄생

딱히 어떤 기술을 의미 하는 것은 아니다. Not Only SQL로 해석 할 수 있음

NoSQL 데이터베이스 채택에는 다음과 같은 다양한 원동력이 있다.

- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
- 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
- 관계형 모델에서 지원하지 않는 특수 질의 동작
- 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

다중 저장소 지속성 (polyglot persistence) : 한 사용 사례에 맞는 최적의 기술 선택은 또다른 사례에 맞는 최적의 선택과는 다를 수 있다. 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용될 것이다.

### 객체 관계형 불일치

객체지향 프로그래밍과 관계형 테이블 사이에 전환 계층이 필요 => 임피던스 불일치(impedance mismatch)
ORM을 사용하면 전환 계층의 코드 양을 줄일 수는 있지만 두 모델 간의 차이를 완벽히 숨길 수는 없다.
예를 들어 인적 사항 정보를 적는 다고 했을 때 이름은 하나만 있어 users 테이블의 컬럼으로 모델링 할 수 있으나 학력 기간과 연락처 정보 같은 경우에는 다른 방법이 필요하다.

- 전통적인 SQL모델에서 가장 일반적인 정규화 표현은 직위, 학력, 연락처 정보를 개별 테이블에 넣고, 외래 키로 users 테이블을 참조하는 방식이다.
- SQL 표준의 마지막 버전에서 구조화된 데이터타입과 XML 데이터에 대한 지원을 추가했다. 이 지원으로 단일 로우에 다중 값을 저장할 수 있고 문서 내 질의와 색인이 가능해졌다.
- 세 번째 방법으로 직업, 학력, 연락처 정보를 JSON이나 XML문서로 부호화해 데이터베이스의 텍스트 칼럼에 저장한 다음 애플리케이션이 구조와 내용을 해석하게 하는 방식이다. 이 방식을 쓰면 일반적으로 부호화된 칼럼의 값을 질의하는 데 데이터베이스를 사용할 수 없다.

JSON 모델의 장점 => 다중 질의 대신 질의 하나로 충분하다.

### 다대일과 다대다 관계

지역을 데이터베이스에 입력할 경우 텍스트의 형태가 아닌 ID의 형태로 저장하면 다음과 같은 장점이 있다.

- 프로필 간 일관된 스타일과 철자
- 모호함 회피 (이름이 같은 도시가 여러 개일 경우)
- 갱신의 편의성. 도시의 이름이 변경됐을 때 바꾸기가 쉽다
- 현지화 지원
- 더 나은 검색

중복된 데이터를 정규화 하려면 다대일 관계(many-to-one)가 필요한데 안타깝게도 다대일 관계는 문서 모델에 적합하지 않다.
관계형 데이터베이스에서는 조인이 쉽기 때문에 ID로 다른 테이블의 로우를 참조하는 방식이 일반적이다. => 조인이 안될 경우 다중 질의를 사용..
애플리케이션의 초기 버전이 조인이 필요 없는 문서 모델이 적합하더라도 기능이 추가되면서 조인이 필요해지는 경향이 있음.
ex.) many-to-many 관계에서는 결국 하나로 묶을 수 있는 데이터 (점선 내)와 그렇지 않은 데이터가 나타나고 이를 위해서 참조와 조인이 필요하다.
[그림 2-4] 

### 문서 데이터베이스는 역사를 반복하고 있나?
문서 모델이 many-to-many를 표현하는데 적합하지 않다면, many-to-many 관계를 표현하는 제일 좋은 방법은 어떤것일까?
개발자에게는 두가지 선택이 있다
- 데이터의 중복을 허용할지
- 참조와 조인을 이용할 지

이에 대한 해결책으로 과거에 제시되었던 두가지 모델이 네트워크 모델과 관계형 모델이며, 이는 다시 관계형 모델에 대한 고민을 가져온다.

#### 네트워크 모델
코다실 모델(CODASYL, Conference on Data System Languages) 모델이라고도 부른다.
네트워크 모델에서 레코드 간 연결은 외래 키보다는 프로그래밍 언어의 포인터와 더 비슷하다. 레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경료를 따르는 방법이다. 이를 접근경로라 한다. 
네트워크 모델은 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못하다.

#### 관계형 모델

네트워크 모델과 대조적으로 관계형 모델은 row의 컬렉션인 table로 이루어져있다. 복잡한 접근 경로가 없고 임의 조건과 일치하는 테이블의 일부 또는 모든 row를 선택해서 읽을 수 있다.
질의 자체를 해석해서 데이터에 접근하는 질의 최적화기가 있으며 이는 이미 만들어진 범용 최적화기가 있으므로 이를 그대로 이용할 수 있는 혜택이 존재한다.

#### 문서 데이터베이스와의 비교
문서 데이터 베이스는 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다는 점에서 계층모델과는 다르다.

다대일 관계나 다대다 관계를 표현함에 있어서 관계형 모델은 외래키를사용하고 문서 모델은 문서참조라는 형태를 사용할 뿐이지 크게 다른 점은 없다.

### 관계형 데이터베이스와 오늘날의 문서 데이터베이스

내결함성이나 동시성 처리등 비교해야할 점이 많지만, 이번 장에서는 데이터 모델의 차이점에 대해서만 집중한다.

- 문서 데이터 모델을 선호 : 스키마 유연성, 지역성에 기인한 더 나은 성능, 일부 애플리케이션의 경우 데이터 구조가 실제 애플리케이션과 더 밀접
- 관계형 모델을 선호 : 조인, 다대일, 다대다 관계를 더 잘 지원

#### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?

일반적으로 얘기할 수는 없다. 상호 연결이 많은 데이터의 경우 문서 모델은 곤란하고 관계형 모델은 무난하며 그래프 모델은 매우 자연스럽다.

- schema-on-write : 관계형 데이터베이스의 전통적인 접근 방식으로 스키마는 명시적이고 데이터 베이스는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다
- schema-on-read : 데이터 구조는 암묵적이고 데이터를 읽을 때만 해석된다.

schema-on-read 항목이 모두 동일한 구조가 아닐때 다음과 같은 이유로 유리하다

- 다른 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다.
- 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.

#### 질의를 위한 데이터 지역성
3장에서 자세히 다룬다

#### 문서 데이터베이스와 관계형 데이터베이스의 통합
데이터베이스 자체가 데이터를 문서처럼 다룰 수 있고 관계형 질의를 수행할 수 있도록 변화 중

### 데이터를 위한 질의 언어

- 명령형 질의 : 프로그래밍 하듯이 순서를 지정하여 질의
- 선언형 질의 : 조건만 제시 순서는 질의 처리기가 알아서
- 맵리듀스 질의 : 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델, mongoDB에서 지원

### 그래프형 데이터 모델

다대다 관계가 매우 많아 진다면 그래프형 데이터 모델을 고려해 볼만하다.

그래프는 두 유형의 객체로 이뤄진다. vertex(node 나 entity라고도 한다)와 edge(relation이나 arc라고도 한다)이다.
vertex는 굳이 같은 유형의 데이터로 이뤄질 필요가 없으며 edge또한 마찬가지이다.

그래프의 질의 방법은 여러가지 가 있는데 이번 장에서는 그중

- 속성 그래프 모델 (Neo4j, Titan, InfiniteGraph)
- 트리플 저장소 모델 (Datomic, Allegrograph)
위 두 모델에 대해 설명하고 그래프용 선언형 질의 언어 세가지, Cypher, SPARQL, Datalog에 대해서 설명한다.

#### 속성그래프

속성 그래프에서 vertex는 다음과 같은 요소로 구성된다.

- 고유한 식별자
- outgoing edge 집합
- incoming edge 집합
- 속성 컬렉션(key-value pair)

edge는 다음과 같은 요소로 구성된다.

- 고유한 식별자
- edge가 시작하는 vertex(tail vertex)
- edge가 끝나는 vertex(head vertex)
- 두 vertex 사이의 관계 유형을 설명하는 레이블
- 속성 컬렉션 (key-value pair)

이 모델의 몇 가지 중요한 면은 다음과 같다.

- vertex는 다른 vertex와 edge로 연결된다. 특정 유형과 관련 여부를 제한하는 schema는 없다.
- vertex가 주어지면 vertex의 outgoing incoming edge를 효율적으로 찾을 수 있고 그래프를 순회할 수 있다.
- 다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.

#### Cypher 질의 언어

Cypher는 속성 그래프를 위한 선언형 질의언어로 Neo4j 그래프 데이터베이스용으로 만들어졌다.

ex.) 미국에서 유럽으로 이민 온 사람을 찾는 사이퍼 질의

```
MATCH
  (person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (us:Location {name:'United States'}),
  (person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'})
RETURN person.name
```

위 질의는 다음과 같이 읽힌다.
다음 두 가지 조건을 만족하는 vertex(person)을 찾아라

- person은 어떤 vertex를 향하는 BORN_IN outgoing edge를 가진다. 이 vertex에서 name 속성이 "United States"인 유형의 vertex에 도달할 때까지 일련의 WITHIN outgoing edge를 따라간다.
- 같은 person vertex는 LIVES_IN  outgoing edge도 가진다. 이 edge와 WITHIN outgoing edge를 따라가면 결국 name 속성이 "Europe"인 Location유형의 vertex에 도달하게 된다.

*** 그래프 데이터를 관계형 구조로 넣어도 SQL을 통해 질의할 수 있지만 어렵다 (WITH RECURSIVE를 이용)***


#### 트리플 저장소와 스파클

트리플 저장소 모델은 속성 그래프 모델과 거의 동등

트리플 저장소에서는 모든 정보를 세 부분 구문 형식으로 저장한다.

트리플의 주어는 그래프의 vertex와 동일하며 목적어는 두 가지 중 하나다.

- 문자열이나 숫자 같은 원시 데이터타입의 값 이 경우 트리플의 서술어와 목적어는 주어 정점에서 속성의 키, 값과 동등하다. 예를 들어 (루시, 나이, 33)은 {"age":33}속성을 가진 vertex lucy와 같다.
- 그래프의 다른 정점, 이 경우 서술어는 그래프의 edge이고 주어는 tail vertex이며 목적어는 head vertex이다. 예를 들어 (루시, 결혼하다, 알랭)에서 주어와 목적어인 루시와 알랭은 모두 vertex이고 서술어 결혼하다는 두 vertex를 잇는 edge의 레이블이다.

##### 스파클 질의 언어

RDF(Resource Description Framework) 데이터 모델을 사용한 트리플 저장소 질의 언어다. 사이퍼와 유사

- 사이퍼: (person) -[:BORN_IN]-> () -[:WITHIN*0..] -> (location)
- 스파클:  ?person : bornIN  / :within* ?location

*** 그래프 데이터베이스는 네트워크 모델이 아니다. ***
- 임의 접근이 가능하며 레코드 타입의 지정이 자유롭고 정렬과정이 없으며, 선언형 질의를 제공한다.


### 초석: 데이터로그
스파클이나 사이퍼보다 훨씬 오래된 언어로 질의 언어의 초석을 제공.

트리플과 달리 주어, 목적어로 작성

```
name(namerica, 'North America').
type(namerica, continent).

name(usa, 'United States').
type(usa, country).
within(usa, namerica).

...
```
